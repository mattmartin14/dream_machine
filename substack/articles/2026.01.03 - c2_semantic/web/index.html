<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>C2 Metrics Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
      :root {
        --bg: #0f172a; /* slate-900 */
        --panel: #111827; /* gray-900 */
        --text: #e5e7eb; /* gray-200 */
        --muted: #9ca3af; /* gray-400 */
        --accent: #60a5fa; /* blue-400 */
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0; padding: 24px; background: var(--bg); color: var(--text);
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      }
      header { display: flex; align-items: baseline; gap: 16px; margin-bottom: 16px; }
      h1 { font-size: 22px; margin: 0; }
      .subtitle { color: var(--muted); font-size: 14px; }
      .grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 16px; max-width: 1600px; margin: 0 auto; }
      .daily-layout { display: grid; grid-template-columns: 360px minmax(0, 1fr); gap: 16px; max-width: 1600px; margin: 0 auto; align-items: start; }
      /* Widen left column (latest + session detail) on larger screens for better readability */
      @media (min-width: 1280px) {
        .daily-layout { grid-template-columns: 480px minmax(0, 1fr); }
      }
      @media (min-width: 1536px) {
        .daily-layout { grid-template-columns: 560px minmax(0, 1fr); }
      }
      .card {
        background: var(--panel); border-radius: 12px; padding: 16px; border: 1px solid rgba(255,255,255,0.06);
        box-shadow: 0 1px 2px rgba(0,0,0,0.25);
      }
      .card h2 { font-size: 16px; margin: 0 0 8px; color: var(--text); }
      .config { display: flex; gap: 8px; align-items: center; margin-bottom: 16px; }
      .config input { flex: 1; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08); background: #0b1220; color: var(--text); }
      .config select { padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.08); background: #0b1220; color: var(--text); min-width: 120px; }
      .config button { padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); background: #0b1220; color: var(--text); cursor: pointer; }
      .radio-group { display: inline-flex; gap: 8px; align-items: center; background: #0b1220; border: 1px solid rgba(255,255,255,0.08); padding: 6px 8px; border-radius: 10px; }
      .radio-group label { display: inline-flex; gap: 6px; align-items: center; cursor: pointer; color: var(--text); }
      .radio-group input[type="radio"] { flex: 0 0 auto; }
      .hint { color: var(--muted); font-size: 12px; margin-top: 8px; }
      /* Chart.js recommends sizing the container, not the canvas, to avoid Safari layout loops */
      .chart-container { position: relative; width: 100%; height: 280px; }
      canvas { width: 100%; }
      a { color: var(--accent); text-decoration: none; }
      /* Tabs */
      .tabs { display: inline-flex; gap: 6px; background: #0b1220; border: 1px solid rgba(255,255,255,0.08); padding: 4px; border-radius: 10px; }
      .tab { appearance: none; border: none; background: transparent; color: var(--text); padding: 6px 10px; border-radius: 8px; cursor: pointer; font-weight: 600; }
      .tab:hover { background: rgba(255,255,255,0.06); }
      .tab.active { background: var(--accent); color: #0b1220; }
      .hidden { display: none; }
      .kpi-value { font-size: 24px; font-weight: 600; color: var(--text); margin-top: 6px; white-space: nowrap; }
      .kpi-subtitle { color: var(--muted); font-size: 12px; }
      .kpi-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .kpi-label { color: var(--muted); }
    </style>
  </head>
  <body>
    <header>
      <h1>C2 Metrics Dashboard</h1>
      <span class="subtitle">Daily and Weekly trends from Cube</span>
    </header>

    <div class="config">
      <label for="cube-url" style="white-space:nowrap">Cube URL:</label>
      <input id="cube-url" type="text" value="http://localhost:4000" />
      <label for="auth-token" style="white-space:nowrap">Auth (optional):</label>
      <input id="auth-token" type="text" placeholder="Bearer <token> or empty in dev" />
      <div class="tabs" role="tablist" aria-label="View selector">
        <button class="tab active" role="tab" aria-selected="true" data-view="daily" data-machine="RowErg">RowErg</button>
        <button class="tab" role="tab" aria-selected="false" data-view="daily" data-machine="SkiErg">SkiErg</button>
        <button class="tab" role="tab" aria-selected="false" data-view="summary">Summary</button>
        <button class="tab" role="tab" aria-selected="false" data-view="watts">Watts</button>
      </div>
      <label for="start-date" style="white-space:nowrap">Start Date:</label>
      <input id="start-date" type="date" value="2025-07-01" style="flex: 0 0 auto;" />
      <label for="use-start-date" style="white-space:nowrap">Use</label>
      <input id="use-start-date" type="checkbox" checked style="flex: 0 0 auto; width: auto;" />
      <div class="radio-group" role="group" aria-label="Distance Filter">
        <span class="subtitle" style="margin-right:4px;">Distance:</span>
        <label><input type="radio" name="distance-filter" value="all" checked /> Show All</label>
        <label><input type="radio" name="distance-filter" value=">5k" /> Show >5k</label>
      </div>
      <button id="reload">Reload Data</button>
    </div>
    <div class="hint">If requests fail, ensure the Cube service is running (docker compose up -d) and update the URL/token as needed.</div>

    <div id="daily-section" class="daily-layout">
      <div id="left-col">
        <div class="card" id="latest-card">
        <h2>Most Recent Workout — <span id="latest-machine">RowErg</span></h2>
        <div class="kpi-row">
          <div>
            <div class="kpi-label">Workout Date</div>
            <div id="latest-date" class="kpi-value">—</div>
          </div>
          <div>
            <div class="kpi-label">Total Distance</div>
            <div id="latest-distance-km" class="kpi-value">—</div>
          </div>
        </div>
        <div class="kpi-row" style="margin-top: 10px;">
          <div>
            <div class="kpi-label">Avg Pace</div>
            <div id="latest-pace" class="kpi-value">—</div>
          </div>
          <div>
            <div class="kpi-label">Avg Watts</div>
            <div id="latest-watts" class="kpi-value">—</div>
          </div>
        </div>
        <div class="kpi-row" style="margin-top: 10px;">
          <div>
            <div class="kpi-label">Avg SPM</div>
            <div id="latest-spm" class="kpi-value">—</div>
          </div>
          <div>
            <div class="kpi-label">Total Time</div>
            <div id="latest-duration" class="kpi-value">—</div>
          </div>
        </div>
        <div class="kpi-subtitle" style="margin-top: 8px;">Shows the most recent day with any workout for the selected machine.</div>
        </div>
        <!-- Session Detail card under the latest workout card -->
        <div class="card" style="margin-top: 16px;">
        <h2><span id="sessionTitle">Session Detail — Watts per Stroke</span> <span id="sessionMeta" class="subtitle"></span></h2>
        <div class="chart-container" style="height: 280px;"><canvas id="sessionDetail"></canvas></div>
        <div id="sessionDetailHint" class="hint">Click a point on Avg Watts — Daily to load session strokes (requires local API).</div>
        </div>
        <!-- Selected Session Summary KPIs -->
        <div class="card" id="session-summary-card" style="margin-top: 16px;">
          <h2>Selected Session — Summary</h2>
          <div class="kpi-row">
            <div>
              <div class="kpi-label">Session Date</div>
              <div id="session-date" class="kpi-value">—</div>
            </div>
            <div>
              <div class="kpi-label">Total Distance</div>
              <div id="session-distance-km" class="kpi-value">—</div>
            </div>
          </div>
          <div class="kpi-row" style="margin-top: 10px;">
            <div>
              <div class="kpi-label">Avg Pace</div>
              <div id="session-pace" class="kpi-value">—</div>
            </div>
            <div>
              <div class="kpi-label">Avg Watts</div>
              <div id="session-watts" class="kpi-value">—</div>
            </div>
          </div>
          <div class="kpi-row" style="margin-top: 10px;">
            <div>
              <div class="kpi-label">Avg SPM</div>
              <div id="session-spm" class="kpi-value">—</div>
            </div>
            <div>
              <div class="kpi-label">Total Time</div>
              <div id="session-duration" class="kpi-value">—</div>
            </div>
          </div>
          <div class="kpi-subtitle" style="margin-top: 8px;">KPIs for the clicked session from the semantic layer.</div>
        </div>
      </div>
      <div>
        <div class="grid">
          <div class="card">
            <h2>Avg Strokes per Minute — Daily</h2>
            <div class="chart-container"><canvas id="spmDaily"></canvas></div>
            <div class="hint">Tip: Click a point to load that day's session detail on the left.</div>
          </div>
          <div class="card">
            <h2>Avg Watts — Daily</h2>
            <div class="chart-container"><canvas id="wattsDaily"></canvas></div>
            <div class="hint">Tip: Click a point to load that day's session detail on the left.</div>
          </div>
          <div class="card">
            <h2>Avg Pace — Daily</h2>
            <div class="chart-container"><canvas id="paceDaily"></canvas></div>
            <div class="hint">Tip: Click a point to load that day's session detail on the left.</div>
          </div>
          <div class="card">
            <h2>Avg Session Duration — Daily</h2>
            <div class="chart-container"><canvas id="durationDaily"></canvas></div>
            <div class="hint">Tip: Click a point to load that day's session detail on the left.</div>
          </div>
        </div>
      </div>
    </div>

    <div id="summary-section" class="grid hidden">
      <div class="card" style="grid-column: span 2;">
        <h2>Monthly Distance (km) — RowErg vs SkiErg</h2>
        <div class="chart-container" style="height: 340px;"><canvas id="distanceMonthlySummary"></canvas></div>
      </div>
      <div class="card" style="grid-column: span 2;">
        <h2>Lifetime Total Distance (km)</h2>
        <div id="kpi-total-km" class="kpi-value">—</div>
        <div class="kpi-subtitle">RowErg + SkiErg</div>
      </div>
      <div class="card">
        <h2>RowErg Total Distance (km)</h2>
        <div id="kpi-row-km" class="kpi-value">—</div>
      </div>
      <div class="card">
        <h2>SkiErg Total Distance (km)</h2>
        <div id="kpi-ski-km" class="kpi-value">—</div>
      </div>
      <div class="card">
        <h2>RowErg Lifetime Avg Pace</h2>
        <div id="kpi-row-pace" class="kpi-value">—</div>
      </div>
      <div class="card">
        <h2>SkiErg Lifetime Avg Pace</h2>
        <div id="kpi-ski-pace" class="kpi-value">—</div>
      </div>
    </div>

    <div id="watts-section" class="grid hidden">
      <div class="card" style="grid-column: span 2;">
        <h2>Avg Watts per Month — RowErg</h2>
        <div class="chart-container" style="height: 340px;"><canvas id="wattsMonthlyRow"></canvas></div>
      </div>
      <div class="card" style="grid-column: span 2;">
        <h2>Avg Watts per Month — SkiErg</h2>
        <div class="chart-container" style="height: 340px;"><canvas id="wattsMonthlySki"></canvas></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
      const DEFAULT_MACHINE = 'RowErg';
      let activeMachine = DEFAULT_MACHINE;
      let activeView = 'daily';
      let selectedDateLabel = null; // cross-chart highlight

      function getConfig() {
        const url = document.getElementById('cube-url').value.trim() || 'http://localhost:4000';
        const token = document.getElementById('auth-token').value.trim();
        const headers = { 'Content-Type': 'application/json' };
        if (token) headers['Authorization'] = token.startsWith('Bearer') ? token : `Bearer ${token}`;
        return { url, headers };
      }

      function getMachine() {
        const el = document.querySelector('.tab.active');
        const v = el?.dataset?.machine || activeMachine || DEFAULT_MACHINE;
        return v.trim();
      }

      function getStartDateEnabled() {
        const cb = document.getElementById('use-start-date');
        return !!cb?.checked;
      }

      function getStartDate() {
        const inp = document.getElementById('start-date');
        const v = (inp?.value || '').trim();
        // Expect yyyy-mm-dd from <input type="date">
        return v;
      }

      function getDistanceFilterMode() {
        const el = document.querySelector('input[name="distance-filter"]:checked');
        const v = (el?.value || 'all').trim();
        return v;
      }

      async function cubeLoad(query) {
        const { url, headers } = getConfig();
        const res = await fetch(`${url}/cubejs-api/v1/load`, {
          method: 'POST',
          headers,
          body: JSON.stringify({ query })
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`Cube load failed (${res.status}): ${text}`);
        }
        return res.json();
      }

      // Generic helpers for daily chart clicks
      function getNearestIndex(chart, evt) {
        let points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, true);
        if (!points || !points.length) {
          points = chart.getElementsAtEventForMode(evt, 'index', { intersect: false }, true);
        }
        if (!points || !points.length) return null;
        return points[0].index;
      }

      async function fetchSessionDetail(dateLabel, machineSel) {
        const hint = document.getElementById('sessionDetailHint');
        try {
          const api = 'http://127.0.0.1:8000/api/session_detail';
          const res = await fetch(`${api}?date=${encodeURIComponent(dateLabel)}&machine=${encodeURIComponent(machineSel)}`);
          const data = await res.json();
          if (!res.ok || data.error) {
            throw new Error(data.error || `API error (${res.status})`);
          }
          return data;
        } catch (e) {
          console.error('Session detail load failed:', e);
          if (hint) hint.textContent = `Failed to load session detail: ${e.message}`;
          throw e;
        }
      }

      async function loadSessionDetailForDate(dateLabel, machineSel) {
        const hint = document.getElementById('sessionDetailHint');
        if (hint) hint.textContent = `Loading session detail for ${machineSel} ${dateLabel}...`;
        try {
          const data = await fetchSessionDetail(dateLabel, machineSel);
          renderSessionDetailChart(data);
          const detail = document.getElementById('sessionDetail');
          if (detail && typeof detail.scrollIntoView === 'function') {
            detail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        } catch (e) {
          // errors handled in fetch
        }
      }

      // Histogram modal helpers
      function ensureHistogramModal() {
        let modal = document.getElementById('spmHistogramModal');
        if (modal) return modal;
        const html = `
          <div id="spmHistogramModal" class="hidden" style="position:fixed; inset:0; z-index:1000; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,0.5);">
            <div class="card" style="width: 720px; max-width: 90vw; position: relative;">
              <button id="spmHistX" type="button" aria-label="Close" title="Close" style="position:absolute; top:8px; right:8px; padding:4px 8px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:#0b1220; color:var(--text); cursor:pointer; z-index: 3;">✕</button>
              <div style="display:flex; justify-content:space-between; align-items:center; padding-right:40px;">
                <h2>SPM Distribution — <span id="spmHistMeta" class="subtitle"></span></h2>
                <button id="spmHistClose" type="button" aria-label="Close" style="padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:#0b1220; color:var(--text); cursor:pointer; position: relative; z-index: 2;" onclick="event && event.stopPropagation(); (function(){var m=document.getElementById('spmHistogramModal'); if(m){m.classList.add('hidden');}})()">Close</button>
              </div>
              <div class="chart-container" style="height: 320px;"><canvas id="spmHistogramCanvas"></canvas></div>
              <div class="hint">Histogram of stroke rates (SPM) for the selected session.</div>
            </div>
          </div>`;
        const container = document.createElement('div');
        container.innerHTML = html;
        document.body.appendChild(container.firstElementChild);
        modal = document.getElementById('spmHistogramModal');
        const closeBtn = document.getElementById('spmHistClose');
        closeBtn?.addEventListener('click', (e) => { e.stopPropagation?.(); hideHistogramModal(); });
        const closeX = document.getElementById('spmHistX');
        closeX?.addEventListener('click', (e) => { e.stopPropagation?.(); hideHistogramModal(); });
        // Close on overlay click
        modal?.addEventListener('click', (e) => {
          const target = e.target;
          if (target && target.id === 'spmHistogramModal') hideHistogramModal();
        });
        // Close on Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') hideHistogramModal();
        });
        return modal;
      }

      function showHistogramModal() {
        const modal = ensureHistogramModal();
        modal.classList.remove('hidden');
      }

      function hideHistogramModal() {
        const modal = document.getElementById('spmHistogramModal');
        if (modal) modal.classList.add('hidden');
      }

      // Global click delegation for robust close handling
      document.addEventListener('click', (e) => {
        const t = e.target;
        if (!t) return;
        // Close button
        if (t.id === 'spmHistClose') {
          hideHistogramModal();
        } else if (typeof t.closest === 'function') {
          const btn = t.closest('#spmHistClose');
          if (btn) hideHistogramModal();
          const btn2 = t.closest('#spmHistX');
          if (btn2) hideHistogramModal();
        }
      });

      function destroySessionChartIfTypeNot(type) {
        if (window.__sessionChart && window.__sessionChart.config && window.__sessionChart.config.type !== type) {
          try { window.__sessionChart.destroy(); } catch {}
          window.__sessionChart = null;
        }
      }

      function renderSPMHistogramInDetail(data) {
        const titleEl = document.getElementById('sessionTitle');
        if (titleEl) titleEl.textContent = 'Session Detail — Distribution of SPM';
        const points = Array.isArray(data?.points) ? data.points : [];
        const rates = points.map(p => {
          const r = p?.stroke_rate;
          return typeof r === 'string' ? parseFloat(r) : r;
        }).filter(r => isFinite(r));
        const dateLabel = data?.date || '';
        const machineSel = data?.machine || '';
        const metaEl = document.getElementById('sessionMeta');
        if (metaEl) {
          const idTxt = data?.log_id ? ` · id ${data.log_id}` : '';
          metaEl.textContent = `(${machineSel} · ${dateLabel}${idTxt})`;
        }

        // Build integer SPM bins from floor(min) to ceil(max)
        const minR = rates.length ? Math.floor(Math.min(...rates)) : 0;
        const maxR = rates.length ? Math.ceil(Math.max(...rates)) : 0;
        const labels = [];
        const counts = [];
        for (let r = minR; r <= maxR; r++) {
          labels.push(String(r));
          counts.push(0);
        }
        rates.forEach(v => {
          const idx = Math.round(v) - minR; // nearest integer bucket
          if (idx >= 0 && idx < counts.length) counts[idx]++;
        });

        // Render bar chart into sessionDetail canvas
        destroySessionChartIfTypeNot('bar');
        const ctx = document.getElementById('sessionDetail');
        if (!ctx) return;
        if (window.__sessionChart) {
          // Update existing bar chart
          const c = window.__sessionChart;
          c.data.labels = labels;
          c.data.datasets = [{ label: 'Stroke Count', data: counts, backgroundColor: '#34d399' }];
          c.options.scales = {
            x: { title: { display: true, text: 'SPM (Strokes per Minute)' }, ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' } },
            y: { title: { display: true, text: 'Stroke Count' }, beginAtZero: true, ticks: { precision: 0, color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' } }
          };
          c.update();
          return;
        }
        window.__sessionChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              label: 'Stroke Count',
              data: counts,
              backgroundColor: '#34d399',
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: {
                  label: (ctx) => `SPM ${ctx.label}: ${ctx.parsed.y} strokes`
                }
              }
            },
            scales: {
              x: { title: { display: true, text: 'SPM (Strokes per Minute)' }, ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' } },
              y: { title: { display: true, text: 'Stroke Count' }, beginAtZero: true, ticks: { precision: 0, color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' } }
            }
          }
        });
      }

      async function loadSPMHistogramForDate(dateLabel, machineSel) {
        try {
          // Ensure modal exists before rendering into it
          ensureHistogramModal();
          const api = 'http://127.0.0.1:8000/api/session_detail';
          const res = await fetch(`${api}?date=${encodeURIComponent(dateLabel)}&machine=${encodeURIComponent(machineSel)}`);
          const data = await res.json();
          if (!res.ok || data.error) {
            throw new Error(data.error || `API error (${res.status})`);
          }
          renderSPMHistogram(data);
          showHistogramModal();
        } catch (e) {
          console.error('SPM histogram load failed:', e);
          alert(`Failed to load SPM histogram: ${e.message}`);
        }
      }

      // Cross-chart selected date highlight
      function setSelectedDate(dateLabel) {
        selectedDateLabel = dateLabel || null;
        updateSelectedHighlight();
      }

      function updateSelectedHighlight() {
        if (!window.__charts || window.__charts.length === 0) return;
        window.__charts.forEach(chart => {
          const labels = chart.data?.labels || [];
          const idx = selectedDateLabel ? labels.indexOf(selectedDateLabel) : -1;
          // Remove existing highlight dataset if present
          const existingIdx = chart.data.datasets.findIndex(d => (d.label || '').toLowerCase() === 'selected date');
          if (existingIdx >= 0) {
            chart.data.datasets.splice(existingIdx, 1);
          }
          if (idx < 0) {
            chart.update();
            return;
          }
          const base = chart.data.datasets[0];
          const values = Array.isArray(base?.data) ? base.data.slice() : [];
          const radius = new Array(labels.length).fill(0);
          radius[idx] = 6;
          const borderWidth = new Array(labels.length).fill(0);
          borderWidth[idx] = 2;
          chart.data.datasets.push({
            label: 'Selected Date',
            type: 'line',
            data: values,
            borderColor: '#f87171',
            backgroundColor: '#f87171',
            pointRadius: radius,
            pointHoverRadius: radius,
            pointBorderWidth: borderWidth,
            showLine: false,
          });
          chart.update();
        });
      }

      function detectTimeKey(row) {
        const keys = Object.keys(row);
        const k = keys.find(k => k.includes('workout_date')) || keys[0];
        return k;
      }

      function detectMachineKey(row) {
        const keys = Object.keys(row);
        const k = keys.find(k => k.toLowerCase().includes('machine')) || keys[0];
        return k;
      }

      function extractSeries(result, measureKey) {
        const rows = result.data || result.loadResponse?.data || [];
        if (rows.length === 0) return { labels: [], values: [] };
        const timeKey = detectTimeKey(rows[0]);
        const labels = rows.map(r => formatDateLabel(r[timeKey]));
        const values = rows.map(r => {
          const val = r[measureKey];
          return normalizeValue(measureKey, val);
        });
        return { labels, values };
      }

      // Format date labels as yyyy-mm-dd (strip time component if present)
      function formatDateLabel(s) {
        if (s == null) return '';
        if (typeof s !== 'string') {
          try { return new Date(s).toISOString().slice(0, 10); } catch { return ''; }
        }
        const t = s.trim();
        // Handles ISO "YYYY-MM-DDTHH:mm:ss..." and plain "YYYY-MM-DD HH:mm:ss"
        if (t.includes('T')) return t.split('T')[0];
        if (t.includes(' ')) return t.split(' ')[0];
        // If already in yyyy-mm-dd, return as-is
        return t.length >= 10 ? t.slice(0,10) : t;
      }

      // Format month labels as yyyy-mm
      function formatMonthLabel(s) {
        const d = formatDateLabel(s);
        return d ? d.slice(0, 7) : '';
      }

      // Normalize measure values; time measures are parsed to seconds
      function normalizeValue(measureKey, val) {
        const isTime = /pace|duration/i.test(measureKey);
        if (!isTime) {
          return typeof val === 'string' ? parseFloat(val) : val;
        }
        return parseTimeToSeconds(val);
      }

      // Accept values like "mm:ss", "m:ss", seconds number, or string seconds
      function parseTimeToSeconds(val) {
        if (val == null) return 0;
        if (typeof val === 'number') return val; // assume already seconds
        if (typeof val === 'string') {
          const s = val.trim();
          if (s.includes(':')) {
            const [mm, ss] = s.split(':');
            const m = parseInt(mm, 10) || 0;
            const sec = parseFloat(ss) || 0; // allow fractional seconds
            return m * 60 + sec;
          }
          const n = parseFloat(s);
          return isNaN(n) ? 0 : n; // assume seconds
        }
        return 0;
      }

      function formatSecondsToMMSS(seconds) {
        const s = Math.max(0, Math.round(seconds));
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${m}:${sec.toString().padStart(2, '0')}`;
      }

      function formatSecondsToMMSSff(seconds) {
        const s = Math.max(0, Number(seconds));
        const m = Math.floor(s / 60);
        const remainder = s - m * 60;
        const secStr = remainder.toFixed(2);
        const [intPart, fracPart] = secStr.split('.')
        const intPadded = (intPart || '0').padStart(2, '0');
        return `${m}:${intPadded}.${fracPart || '00'}`;
      }

      function formatMinutesToMMSS(minutes) {
        const s = Math.round((typeof minutes === 'string' ? parseFloat(minutes) : minutes) * 60);
        return formatSecondsToMMSS(s);
      }

      function makeLineChart(ctx, { labels, values }, color, label, valueFormatter, yOptions, extraDatasets, meta) {
        return new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label,
              data: values,
              borderColor: color,
              backgroundColor: color,
              tension: 0.25,
              fill: false,
              pointRadius: 2,
            }].concat(extraDatasets || [])
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true },
              tooltip: {
                mode: 'index', intersect: false,
                callbacks: {
                  title: (items) => {
                    const raw = items?.[0]?.label ?? '';
                    return raw; // labels are already yyyy-mm-dd
                  },
                  label: (ctx) => {
                    const raw = ctx.parsed?.y;
                    const isTrend = /trend/i.test(ctx.dataset?.label || '');
                    if (isTrend) {
                      // For time series trend (pace/duration), show mm:ss.ff; otherwise 2 decimals
                      if (valueFormatter === formatSecondsToMMSS) {
                        return `${ctx.dataset.label}: ${formatSecondsToMMSSff(raw)}`;
                      }
                      return `${ctx.dataset.label}: ${isFinite(raw) ? Number(raw).toFixed(2) : raw}`;
                    }
                    const v = valueFormatter ? valueFormatter(raw) : raw;
                    let base = `${ctx.dataset.label}: ${v}`;
                    // Append total distance for the Avg Watts daily chart when provided
                    if ((ctx.dataset?.label || '').toLowerCase() === 'avg watts') {
                      const idx = ctx.dataIndex;
                      const dist = meta?.distanceKm?.[idx];
                      if (isFinite(dist)) {
                        const distTxt = (Math.round(dist * 10) / 10).toFixed(1);
                        const distLine = `Total Distance: ${distTxt} km`;
                        return [base, distLine];
                      }
                    }
                    return base;
                  }
                }
              }
            },
            scales: {
              x: {
                ticks: {
                  color: '#cbd5e1',
                  // labels already formatted; return as-is for clarity
                  callback: (value, index, ticks) => labels[index]
                },
                grid: { color: 'rgba(255,255,255,0.06)' }
              },
              y: {
                ticks: {
                  color: '#cbd5e1',
                  callback: (value) => (valueFormatter ? valueFormatter(value) : value),
                  stepSize: yOptions?.stepSize
                },
                grid: { color: 'rgba(255,255,255,0.06)' },
                beginAtZero: yOptions?.beginAtZero ?? (valueFormatter ? false : true),
                min: yOptions?.min,
                max: yOptions?.max
              }
            }
          }
        });
      }

      // Global plugin to draw total labels atop each stacked bar
      const StackedTotalLabelPlugin = {
        id: 'stackedTotalLabel',
        afterDraw(chart, args, opts) {
          const ctx = chart.ctx;
          const yScale = chart.scales['y'];
          const xScale = chart.scales['x'];
          const area = chart.chartArea || {};
          if (!yScale || !xScale) return;
          const metas = chart.getSortedVisibleDatasetMetas().filter(m => m.type === 'bar' && !m.hidden);
          if (metas.length === 0) return;
          const count = metas[0].data.length;

          ctx.save();
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          const color = opts?.color || '#e5e7eb';
          const fontSize = opts?.font?.size || 12;
          const fontWeight = opts?.font?.weight || 'bold';
          ctx.fillStyle = color;
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.lineWidth = 3;
          ctx.font = `${fontWeight} ${fontSize}px Inter, system-ui, -apple-system, sans-serif`;

          for (let i = 0; i < count; i++) {
            let sum = 0;
            metas.forEach(m => {
              const v = m.dataset?.data?.[i];
              const n = typeof v === 'string' ? parseFloat(v) : v;
              if (isFinite(n)) sum += n;
            });
            if (!isFinite(sum) || sum <= 0) continue;

            const el = metas[metas.length - 1].data[i] || metas[0].data[i];
            const x = el?.x ?? xScale.getPixelForValue(i);
            let y = yScale.getPixelForValue(sum) - 6;
            if (typeof area.top === 'number') y = Math.max(area.top + 6, y);

            const text = (opts && typeof opts.formatter === 'function') ? opts.formatter(sum) : `${sum.toFixed(1)} km`;
            // Outline then fill for readability
            ctx.strokeText(text, x, y);
            ctx.fillText(text, x, y);
          }

          ctx.restore();
        }
      };
      // Register plugin globally so per-chart options take effect
      Chart.register(StackedTotalLabelPlugin);

      function makeStackedBarChart(ctx, labels, datasets) {
        return new Chart(ctx, {
          type: 'bar',
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true },
              tooltip: {
                mode: 'index', intersect: false,
                callbacks: {
                  footer: (items) => {
                    if (!items || items.length === 0) return '';
                    const idx = items[0].dataIndex;
                    const chart = items[0].chart;
                    let sum = 0;
                    const ds = chart.data?.datasets ?? [];
                    for (const d of ds) {
                      // Treat datasets with explicit type 'line' as overlays; only sum bars.
                      const t = (d.type || chart.config?.type || 'bar');
                      if (t === 'line') continue;
                      const v = d.data?.[idx];
                      const n = typeof v === 'string' ? parseFloat(v) : v;
                      if (isFinite(n)) sum += n;
                    }
                    return `Total: ${sum.toFixed(1)} km`;
                  }
                }
              },
              stackedTotalLabel: {
                color: '#e5e7eb',
                font: { size: 12, weight: 'bold' },
                formatter: (v) => `${v.toFixed(1)} km`
              }
            },
            scales: {
              x: { stacked: true, ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' } },
              y: { stacked: true, ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' }, beginAtZero: true }
            }
          },
          plugins: [StackedTotalLabelPlugin]
        });
      }

      // Compute a simple linear regression trend line over series values
      function computeLinearTrend(values) {
        const n = values.length;
        if (!values || n === 0) return [];
        const xs = []; const ys = [];
        for (let i = 0; i < n; i++) {
          const v = values[i];
          if (isFinite(v)) { xs.push(i); ys.push(v); }
        }
        if (xs.length < 2) return Array(n).fill(null);
        const mean = (arr) => arr.reduce((a, b) => a + b, 0) / arr.length;
        const mx = mean(xs);
        const my = mean(ys);
        let num = 0, den = 0;
        for (let i = 0; i < xs.length; i++) {
          const dx = xs[i] - mx;
          const dy = ys[i] - my;
          num += dx * dy;
          den += dx * dx;
        }
        if (den === 0) return Array(n).fill(null);
        const slope = num / den;
        const intercept = my - slope * mx;
        const trend = new Array(n);
        for (let i = 0; i < n; i++) trend[i] = slope * i + intercept;
        return trend;
      }

      function computeMoMPercent(values) {
        const out = new Array(values.length).fill(null);
        for (let i = 1; i < values.length; i++) {
          const prev = values[i-1];
          const curr = values[i];
          if (isFinite(prev) && isFinite(curr) && prev !== 0) {
            out[i] = ((curr - prev) / prev) * 100.0;
          } else {
            out[i] = null;
          }
        }
        return out;
      }

      function makeComboBarLineChart(ctx, labels, barValues, lineValues, dragValues, distValues, colors, labelBar, labelLine) {
        return new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [
              {
                type: 'bar',
                label: labelBar,
                data: barValues,
                backgroundColor: colors.bar,
                borderColor: colors.bar,
                yAxisID: 'y',
              },
              {
                type: 'line',
                label: labelLine,
                data: lineValues,
                borderColor: colors.line,
                backgroundColor: colors.line,
                tension: 0,
                fill: false,
                pointRadius: 2,
                yAxisID: 'y1',
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true },
              tooltip: {
                mode: 'index', intersect: false,
                callbacks: {
                  title: (items) => items?.[0]?.label ?? '',
                  label: (ctx) => {
                    if (ctx.dataset.yAxisID === 'y1') {
                      const v = ctx.parsed?.y;
                      const base = `${ctx.dataset.label}: ${isFinite(v) ? v.toFixed(1) + '% MoM' : '—'}`;
                      const idx = ctx.dataIndex;
                      const drag = dragValues?.[idx];
                      const dragTxt = isFinite(drag) ? ` | Avg Drag: ${Number(drag).toFixed(0)}` : '';
                      return base + dragTxt;
                    }
                    const v = ctx.parsed?.y;
                    const base = `${ctx.dataset.label}: ${isFinite(v) ? v.toFixed(1) + ' W' : '—'}`;
                    const idx = ctx.dataIndex;
                    const drag = dragValues?.[idx];
                    const dragTxt = isFinite(drag) ? ` | Avg Drag: ${Number(drag).toFixed(0)}` : '';
                    const dist = distValues?.[idx];
                    if (isFinite(dist)) {
                      const distLine = `Total Distance: ${(Math.round(dist * 10) / 10).toFixed(1)} km`;
                      // First line: watts + drag on same line; second line: distance
                      return [base + dragTxt, distLine];
                    }
                    return base + dragTxt;
                  }
                }
              }
            },
            scales: {
              x: { ticks: { color: '#cbd5e1', callback: (v, i) => labels[i] }, grid: { color: 'rgba(255,255,255,0.06)' } },
              y: {
                position: 'left',
                ticks: { color: '#cbd5e1' },
                grid: { color: 'rgba(255,255,255,0.06)' },
                ...computeNumericAxisOptions(barValues)
              },
              y1: {
                position: 'right',
                ticks: { color: '#cbd5e1', callback: (v) => `${v}%` },
                grid: { drawOnChartArea: false },
                ...computePercentAxisOptions(lineValues)
              }
            }
          }
        });
      }

      function computeTimeAxisOptions(values) {
        if (!values || values.length === 0) return {};
        const min = Math.min(...values);
        const max = Math.max(...values);
        if (!isFinite(min) || !isFinite(max)) return {};
        const range = Math.max(1, max - min);
        const padding = Math.max(3, Math.round(range * 0.08)); // ~8% padding, at least 3s
        const yMin = Math.max(0, min - padding);
        const yMax = max + padding;
        let step;
        if (range <= 60) step = 5;           // 5s ticks for <=1 min range
        else if (range <= 120) step = 10;    // 10s ticks for <=2 min range
        else if (range <= 300) step = 15;    // 15s ticks for <=5 min range
        else step = 30;                      // 30s otherwise
        return { min: yMin, max: yMax, stepSize: step };
      }

      function computeNumericAxisOptions(values) {
        if (!values || values.length === 0) return {};
        const min = Math.min(...values);
        const max = Math.max(...values);
        if (!isFinite(min) || !isFinite(max)) return {};
        const range = Math.max(1e-6, max - min);
        const padding = Math.max(1, Math.round(range * 0.08)); // ~8% padding, at least 1 unit
        const yMin = min - padding;
        const yMax = max + padding;
        const r = yMax - yMin;
        let step;
        if (r <= 5) step = 1;
        else if (r <= 10) step = 2;
        else if (r <= 20) step = 5;
        else if (r <= 50) step = 10;
        else if (r <= 100) step = 20;
        else step = 50;
        return { min: yMin, max: yMax, stepSize: step, beginAtZero: false };
      }

      function computePercentAxisOptions(values) {
        if (!values || values.length === 0) return { min: -50, max: 50, stepSize: 10 };
        const arr = values.filter(v => isFinite(v));
        if (arr.length === 0) return { min: -50, max: 50, stepSize: 10 };
        const min = Math.min(...arr);
        const max = Math.max(...arr);
        const pad = Math.max(2, Math.round((max - min) * 0.1));
        const yMin = Math.floor(Math.min(-5, min - pad));
        const yMax = Math.ceil(Math.max(5, max + pad));
        return { min: yMin, max: yMax, stepSize: 5, beginAtZero: false };
      }

      function quantile(values, q) {
        const arr = (values || []).filter(v => isFinite(v)).slice().sort((a,b) => a-b);
        const n = arr.length;
        if (n === 0) return NaN;
        const idx = (n - 1) * q;
        const lo = Math.floor(idx);
        const hi = Math.ceil(idx);
        if (lo === hi) return arr[lo];
        const h = idx - lo;
        return arr[lo] + h * (arr[hi] - arr[lo]);
      }

      function computeSPMAxisOptions(values) {
        if (!values || values.length === 0) return {};
        const p05 = quantile(values, 0.05);
        const p95 = quantile(values, 0.95);
        if (!isFinite(p05) || !isFinite(p95)) return computeNumericAxisOptions(values);
        const range = Math.max(1e-6, p95 - p05);
        const pad = Math.max(0.3, range * 0.08); // ~8% padding, at least 0.3 spm
        const yMin = Math.max(0, p05 - pad);
        const yMax = p95 + pad;
        const r = yMax - yMin;
        let step;
        if (r <= 2) step = 0.2;
        else if (r <= 4) step = 0.5;
        else if (r <= 10) step = 1;
        else step = 2;
        return { min: yMin, max: yMax, stepSize: step, beginAtZero: false };
      }

      function getSPMYAxisOptions(machine, values) {
        if (machine === 'RowErg') return { min: 15, max: 30, stepSize: 1, beginAtZero: false };
        if (machine === 'SkiErg') return { min: 30, max: 50, stepSize: 1, beginAtZero: false };
        return computeSPMAxisOptions(values);
      }

      async function loadAll() {
        const dailyQuery = {
          timeDimensions: [{ dimension: 'c2_cube.workout_date', granularity: 'day' }],
          measures: ['c2_cube.avg_watts', 'c2_cube.avg_spm', 'c2_cube.avg_pace', 'c2_cube.avg_session_duration', 'c2_cube.total_distance_km'],
          filters: [
            { member: 'c2_cube.machine', operator: 'equals', values: [getMachine()] },
            { member: 'c2_cube.total_session_minutes', operator: 'gte', values: ['5'] },
          ]
        };

        // Apply distance filter to include only sessions >5k (5 km - 6 km, 6 km - 7 km, >= 7 km)
        if (getDistanceFilterMode() === '>5k') {
          dailyQuery.filters.push({ member: 'c2_cube.distance_block', operator: 'equals', values: ['5 km - 6 km', '6 km - 7 km', '>= 7 km'] });
        }

        if (getStartDateEnabled()) {
          const sd = getStartDate();
          if (sd) {
            dailyQuery.filters.push({ member: 'c2_cube.workout_date', operator: 'afterOrOnDate', values: [sd] });
          }
        }

        try {
          const dailyRes = await cubeLoad(dailyQuery);
          const spmDaily = extractSeries(dailyRes, 'c2_cube.avg_spm');
          const wattsDaily = extractSeries(dailyRes, 'c2_cube.avg_watts');
          const paceDaily = extractSeries(dailyRes, 'c2_cube.avg_pace');
          const durationDaily = extractSeries(dailyRes, 'c2_cube.avg_session_duration');
          const distDaily = extractSeries(dailyRes, 'c2_cube.total_distance_km');

          // Destroy existing charts if any
          window.__charts?.forEach(c => c.destroy());
          window.__charts = [];

          const machine = getMachine();
          const spmChart = makeLineChart(
              document.getElementById('spmDaily'),
              spmDaily,
              '#34d399',
              'Avg SPM',
              undefined,
              getSPMYAxisOptions(machine, spmDaily.values)
            );
          const wattsDailyChart = makeLineChart(
              document.getElementById('wattsDaily'),
              wattsDaily,
              '#60a5fa',
              'Avg Watts',
              undefined,
              computeNumericAxisOptions(wattsDaily.values),
              [{
                label: 'Avg Watts Trend',
                data: computeLinearTrend(wattsDaily.values),
                borderColor: '#93c5fd',
                backgroundColor: '#93c5fd',
                tension: 0,
                fill: false,
                pointRadius: 0,
                borderDash: [6, 6],
              }],
              { distanceKm: distDaily.values }
            );
          const paceChart = makeLineChart(
              document.getElementById('paceDaily'),
              paceDaily,
              '#22d3ee',
              'Avg Pace',
              formatSecondsToMMSS,
              computeTimeAxisOptions(paceDaily.values),
              [{
                label: 'Avg Pace Trend',
                data: computeLinearTrend(paceDaily.values),
                borderColor: '#7dd3fc',
                backgroundColor: '#7dd3fc',
                tension: 0,
                fill: false,
                pointRadius: 0,
                borderDash: [6, 6],
              }]
            );
          const durationChart = makeLineChart(
              document.getElementById('durationDaily'),
              durationDaily,
              '#f59e0b',
              'Avg Session Duration',
              formatSecondsToMMSS,
              computeTimeAxisOptions(durationDaily.values),
              [{
                label: 'Avg Session Duration Trend',
                data: computeLinearTrend(durationDaily.values),
                borderColor: '#fcd34d',
                backgroundColor: '#fcd34d',
                tension: 0,
                fill: false,
                pointRadius: 0,
                borderDash: [6, 6],
              }]
            );

          window.__charts.push(spmChart, wattsDailyChart, paceChart, durationChart);
          // Re-apply highlight after charts are recreated
          updateSelectedHighlight();

          // Click handler for Avg Watts — Daily to load session detail
          wattsDailyChart.canvas.onclick = async (evt) => {
            const idx = getNearestIndex(wattsDailyChart, evt);
            if (idx == null) return;
            const dateLabel = wattsDaily.labels[idx];
            const machineSel = getMachine();
            setSelectedDate(dateLabel);
            await loadSessionDetailForDate(dateLabel, machineSel);
          };

          // Click handlers for other daily charts
          spmChart.canvas.onclick = async (evt) => {
            const idx = getNearestIndex(spmChart, evt);
            if (idx == null) return;
            const dateLabel = spmDaily.labels[idx];
            const machineSel = getMachine();
            setSelectedDate(dateLabel);
            // For SPM chart, render histogram in Session Detail area
            try {
              const data = await fetchSessionDetail(dateLabel, machineSel);
              renderSPMHistogramInDetail(data);
              const detail = document.getElementById('sessionDetail');
              if (detail && typeof detail.scrollIntoView === 'function') {
                detail.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              }
              // Load summary KPIs for the selected session via Cube
              await loadSessionSummaryByDay(dateLabel, machineSel);
            } catch (e) {}
          };
          paceChart.canvas.onclick = async (evt) => {
            const idx = getNearestIndex(paceChart, evt);
            if (idx == null) return;
            const dateLabel = paceDaily.labels[idx];
            const machineSel = getMachine();
            setSelectedDate(dateLabel);
            await loadSessionDetailForDate(dateLabel, machineSel);
          };
          durationChart.canvas.onclick = async (evt) => {
            const idx = getNearestIndex(durationChart, evt);
            if (idx == null) return;
            const dateLabel = durationDaily.labels[idx];
            const machineSel = getMachine();
            setSelectedDate(dateLabel);
            await loadSessionDetailForDate(dateLabel, machineSel);
          };
        } catch (e) {
          console.error(e);
          alert(e.message);
        }

        // Load latest workout card (includes all workouts, no 10-min filter)
        try {
          await loadLatestWorkoutCard();
        } catch (e) {
          console.warn('Latest workout card load failed:', e);
        }
      }

      // Render or update the Session Detail chart
      function renderSessionDetailChart(payload) {
        const titleEl = document.getElementById('sessionTitle');
        if (titleEl) titleEl.textContent = 'Session Detail — Watts per Stroke';
        // Ensure chart is a line chart; destroy if currently another type
        try { destroySessionChartIfTypeNot('line'); } catch {}
        const metaEl = document.getElementById('sessionMeta');
        if (metaEl) {
          const idTxt = payload?.log_id ? ` · id ${payload.log_id}` : '';
          metaEl.textContent = `(${payload?.machine || ''} · ${payload?.date || ''}${idTxt})`;
        }
        const hint = document.getElementById('sessionDetailHint');
        if (hint) hint.textContent = '';

        // Drop the first couple of strokes which are often outliers when starting
        const SKIP_INITIAL_STROKES = 2;
        const points = (payload?.points || []).slice(SKIP_INITIAL_STROKES);
        const labels = points.map(p => (p.x ?? p.stroke_number));
        const watts = points.map(p => (p.y ?? p.watts));
        // Derive pace in seconds by prioritizing the formatted string column
        const paceSecondsSeries = points.map(p => {
          if (p && typeof p.pace_mm_ss_ff === 'string' && p.pace_mm_ss_ff.trim()) {
            return parseTimeToSeconds(p.pace_mm_ss_ff.trim());
          }
          if (typeof p?.pace_seconds === 'number' && isFinite(p.pace_seconds)) {
            return p.pace_seconds;
          }
          return null;
        });
        const hasAnyPace = paceSecondsSeries.some(v => typeof v === 'number' && isFinite(v));
        // Compute nice axis bounds for pace
        const paceAxis = hasAnyPace ? computeTimeAxisOptions(paceSecondsSeries) : {};

        if (!window.__sessionChart) {
          window.__sessionChart = new Chart(
            document.getElementById('sessionDetail'),
            {
              type: 'line',
              data: {
                labels,
                datasets: [{
                  label: 'Watts per Stroke',
                  data: watts,
                  borderColor: '#60a5fa',
                  backgroundColor: '#60a5fa',
                  tension: 0.15,
                  pointRadius: 1.5,
                  fill: false,
                  yAxisID: 'y',
                }].concat(hasAnyPace ? [{
                  label: 'Pace',
                  data: paceSecondsSeries,
                  borderColor: '#22d3ee',
                  backgroundColor: '#22d3ee',
                  tension: 0.15,
                  pointRadius: 1.2,
                  fill: false,
                  yAxisID: 'y1',
                  spanGaps: true,
                }] : [])
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: true },
                  tooltip: {
                    callbacks: {
                      label: (ctx) => {
                        const name = ctx.dataset?.label || '';
                        const val = ctx.parsed?.y;
                        if (name === 'Pace') {
                          const idx = ctx.dataIndex;
                          const rawStr = points?.[idx]?.pace_mm_ss_ff;
                          return `${name}: ${rawStr && typeof rawStr === 'string' ? rawStr : formatSecondsToMMSSff(val)}`;
                        }
                        return `${name}: ${isFinite(val) ? Math.round(val) : val}`;
                      }
                    }
                  }
                },
                scales: {
                  x: { ticks: { color: '#cbd5e1' }, grid: { color: 'rgba(255,255,255,0.06)' } },
                  y: {
                    ticks: { color: '#cbd5e1' },
                    grid: { color: 'rgba(255,255,255,0.06)' },
                    beginAtZero: false,
                    title: { display: true, text: 'Watts', color: '#cbd5e1' }
                  },
                  y1: {
                    position: 'right',
                    ticks: {
                      color: '#cbd5e1',
                      callback: (v) => formatSecondsToMMSSff(v)
                    },
                    grid: { drawOnChartArea: false },
                    beginAtZero: false,
                    min: paceAxis.min,
                    max: paceAxis.max,
                    suggestedMin: paceAxis.min,
                    suggestedMax: paceAxis.max,
                    title: { display: true, text: 'Pace', color: '#cbd5e1' }
                  }
                }
              }
            }
          );
        } else {
          const c = window.__sessionChart;
          c.data.labels = labels;
          c.data.datasets[0].data = watts;
          // Update or toggle the pace dataset
          const hasPaceDataset = c.data.datasets.length > 1 && c.data.datasets[1]?.label === 'Pace';
          if (hasAnyPace) {
            if (hasPaceDataset) {
              c.data.datasets[1].data = paceSecondsSeries;
            } else {
              c.data.datasets.push({
                label: 'Pace',
                data: paceSecondsSeries,
                borderColor: '#22d3ee',
                backgroundColor: '#22d3ee',
                tension: 0.15,
                pointRadius: 1.2,
                fill: false,
                yAxisID: 'y1',
                spanGaps: true,
              });
            }
            // Update pace axis bounds
            const paceAxis = computeTimeAxisOptions(paceSecondsSeries);
            c.options.scales.y1.min = paceAxis.min;
            c.options.scales.y1.max = paceAxis.max;
          } else if (hasPaceDataset) {
            c.data.datasets.pop();
          }
          c.update();
        }
        // Also load summary KPIs for the selected session via Cube
        if (payload && typeof payload.log_id !== 'undefined' && payload.log_id !== null) {
          loadSessionSummaryById(payload.log_id).catch(err => console.warn('Session summary load by id failed:', err));
        } else if (payload && payload.date && payload.machine) {
          loadSessionSummaryByDay(payload.date, payload.machine).catch(err => console.warn('Session summary load by day failed:', err));
        }
      }

      async function loadSessionSummaryById(logId) {
        const query = {
          measures: ['c2_cube.total_distance_km', 'c2_cube.avg_pace', 'c2_cube.avg_watts', 'c2_cube.total_session_minutes', 'c2_cube.avg_spm'],
          dimensions: ['c2_cube.workout_date'],
          filters: [
            { member: 'c2_cube.id', operator: 'equals', values: [String(logId)] }
          ],
          limit: 1
        };
        const res = await cubeLoad(query);
        const rows = res.data || res.loadResponse?.data || [];
        updateSessionSummaryFromRow(rows[0]);
      }

      async function loadSessionSummaryByDay(dateLabel, machineSel) {
        const query = {
          timeDimensions: [{ dimension: 'c2_cube.workout_date', granularity: 'day', dateRange: [dateLabel, dateLabel] }],
          measures: ['c2_cube.total_distance_km', 'c2_cube.avg_pace', 'c2_cube.avg_watts', 'c2_cube.total_session_minutes', 'c2_cube.avg_spm'],
          dimensions: ['c2_cube.workout_date'],
          filters: [
            { member: 'c2_cube.machine', operator: 'equals', values: [machineSel] },
          ],
          limit: 1
        };
        const res = await cubeLoad(query);
        const rows = res.data || res.loadResponse?.data || [];
        updateSessionSummaryFromRow(rows[0]);
      }

      function updateSessionSummaryFromRow(r) {
        const setText = (id, txt) => { const el = document.getElementById(id); if (el) el.textContent = txt; };
        if (!r) {
          setText('session-date', '—');
          setText('session-distance-km', '—');
          setText('session-pace', '—');
          setText('session-watts', '—');
          setText('session-spm', '—');
          setText('session-duration', '—');
          return;
        }
        const timeKey = detectTimeKey(r);
        const dateLabel = formatDateLabel(r[timeKey]);
        const distKm = typeof r['c2_cube.total_distance_km'] === 'string' ? parseFloat(r['c2_cube.total_distance_km']) : r['c2_cube.total_distance_km'];
        const watts = typeof r['c2_cube.avg_watts'] === 'string' ? parseFloat(r['c2_cube.avg_watts']) : r['c2_cube.avg_watts'];
        const pace = r['c2_cube.avg_pace'];
        const spm = typeof r['c2_cube.avg_spm'] === 'string' ? parseFloat(r['c2_cube.avg_spm']) : r['c2_cube.avg_spm'];
        const minutes = typeof r['c2_cube.total_session_minutes'] === 'string' ? parseFloat(r['c2_cube.total_session_minutes']) : r['c2_cube.total_session_minutes'];

        setText('session-date', dateLabel || '—');
        setText('session-distance-km', isFinite(distKm) ? `${(Math.round(distKm * 100) / 100).toFixed(2)} km` : '—');
        setText('session-pace', pace ? formatSecondsToMMSSff(parseTimeToSeconds(pace)) : '—');
        setText('session-watts', isFinite(watts) ? `${Math.round(watts)} W` : '—');
        setText('session-spm', isFinite(spm) ? `${Number(spm).toFixed(1)} spm` : '—');
        setText('session-duration', isFinite(minutes) ? formatMinutesToMMSS(minutes) : '—');
      }

      async function loadLatestWorkoutCard() {
        const query = {
          timeDimensions: [{ dimension: 'c2_cube.workout_date', granularity: 'day' }],
          measures: ['c2_cube.total_distance_km', 'c2_cube.avg_pace', 'c2_cube.avg_watts', 'c2_cube.total_session_minutes', 'c2_cube.avg_spm'],
          dimensions: ['c2_cube.workout_date'],
          filters: [
            { member: 'c2_cube.machine', operator: 'equals', values: [getMachine()] },
          ],
          order: { 'c2_cube.workout_date': 'desc' },
          limit: 1
        };
        const res = await cubeLoad(query);
        const rows = res.data || res.loadResponse?.data || [];
        const r = rows[0];
        document.getElementById('latest-machine').textContent = getMachine();
        if (!r) {
          document.getElementById('latest-date').textContent = '—';
          document.getElementById('latest-distance-km').textContent = '—';
          document.getElementById('latest-pace').textContent = '—';
          document.getElementById('latest-watts').textContent = '—';
          document.getElementById('latest-duration').textContent = '—';
          return;
        }
        const timeKey = detectTimeKey(r);
        const dateLabel = formatDateLabel(r[timeKey]);
        const distKm = typeof r['c2_cube.total_distance_km'] === 'string' ? parseFloat(r['c2_cube.total_distance_km']) : r['c2_cube.total_distance_km'];
        const watts = typeof r['c2_cube.avg_watts'] === 'string' ? parseFloat(r['c2_cube.avg_watts']) : r['c2_cube.avg_watts'];
        const pace = r['c2_cube.avg_pace'];
        const spm = typeof r['c2_cube.avg_spm'] === 'string' ? parseFloat(r['c2_cube.avg_spm']) : r['c2_cube.avg_spm'];
        const minutes = typeof r['c2_cube.total_session_minutes'] === 'string' ? parseFloat(r['c2_cube.total_session_minutes']) : r['c2_cube.total_session_minutes'];

        document.getElementById('latest-date').textContent = dateLabel || '—';
        document.getElementById('latest-distance-km').textContent = isFinite(distKm) ? `${(Math.round(distKm * 10) / 10).toFixed(1)} km` : '—';
        document.getElementById('latest-pace').textContent = pace ? formatSecondsToMMSSff(parseTimeToSeconds(pace)) : '—';
        document.getElementById('latest-spm').textContent = isFinite(spm) ? `${Number(spm).toFixed(1)} spm` : '—';
        document.getElementById('latest-watts').textContent = isFinite(watts) ? `${Math.round(watts)} W` : '—';
        document.getElementById('latest-duration').textContent = isFinite(minutes) ? formatMinutesToMMSS(minutes) : '—';
      }

      async function loadSummary() {
        const monthlyQuery = {
          timeDimensions: [{ dimension: 'c2_cube.workout_date', granularity: 'month' }],
          measures: ['c2_cube.total_distance_with_rest_km'],
          dimensions: ['c2_cube.machine'],
          filters: [
            { member: 'c2_cube.machine', operator: 'equals', values: ['RowErg', 'SkiErg'] },
          ],
          order: { 'c2_cube.workout_date': 'asc' }
        };

        try {
          const res = await cubeLoad(monthlyQuery);
          const rows = res.data || res.loadResponse?.data || [];
          const labelsSet = new Set();
          const timeKey = rows[0] ? detectTimeKey(rows[0]) : 'c2_cube.workout_date';
          const machineKey = rows[0] ? detectMachineKey(rows[0]) : 'c2_cube.machine';
          const valKey = 'c2_cube.total_distance_with_rest_km';
          const byMonthMachine = {};
          rows.forEach(r => {
            const mLabel = formatMonthLabel(r[timeKey]);
            const machine = (r[machineKey] || '').trim();
            labelsSet.add(mLabel);
            byMonthMachine[mLabel] = byMonthMachine[mLabel] || { RowErg: 0, SkiErg: 0 };
            const v = typeof r[valKey] === 'string' ? parseFloat(r[valKey]) : r[valKey];
            if (machine === 'RowErg' || machine === 'SkiErg') {
              byMonthMachine[mLabel][machine] += (isFinite(v) ? v : 0);
            }
          });
          const labels = Array.from(labelsSet).sort();
          const rowKm = labels.map(l => byMonthMachine[l]?.RowErg ?? 0);
          const skiKm = labels.map(l => byMonthMachine[l]?.SkiErg ?? 0);

          // Destroy existing charts
          window.__charts?.forEach(c => c.destroy());
          window.__charts = [];

          // Build per-year average trend line datasets
          const totals = labels.map((l, i) => {
            const rk = typeof rowKm[i] === 'string' ? parseFloat(rowKm[i]) : rowKm[i];
            const sk = typeof skiKm[i] === 'string' ? parseFloat(skiKm[i]) : skiKm[i];
            const r = (isFinite(rk) ? rk : 0) + (isFinite(sk) ? sk : 0);
            return isFinite(r) ? r : 0;
          });
          const years = Array.from(new Set(labels.map(l => (l || '').slice(0,4)))).sort();
          const yearColors = ['#f59e0b', '#f87171', '#a78bfa', '#34d399', '#ef4444', '#eab308'];
          const fmtKm = (n) => new Intl.NumberFormat('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(n);
          const lineDatasets = years.map((y, idx) => {
            // compute average for this year
            let sum = 0, count = 0;
            for (let i = 0; i < labels.length; i++) {
              if (labels[i].startsWith(y)) {
                const v = totals[i];
                if (isFinite(v)) { sum += v; count += 1; }
              }
            }
            const avg = count > 0 ? (sum / count) : null;
            const data = labels.map(l => l.startsWith(y) && isFinite(avg) ? avg : null);
            const color = yearColors[idx % yearColors.length];
            return {
              type: 'line',
              label: `${y} Avg: ${avg != null ? fmtKm(avg) + ' km' : '—'}`,
              data,
              borderColor: color,
              backgroundColor: color,
              tension: 0,
              fill: false,
              pointRadius: 0,
              yAxisID: 'y',
              borderDash: [6, 6],
              spanGaps: true,
            };
          });

          const summaryDatasets = [
            { label: 'RowErg', data: rowKm, backgroundColor: '#60a5fa', stack: 'distance' },
            { label: 'SkiErg', data: skiKm, backgroundColor: '#22d3ee', stack: 'distance' },
          ].concat(lineDatasets);

          window.__charts.push(
            makeStackedBarChart(
              document.getElementById('distanceMonthlySummary'),
              labels,
              summaryDatasets
            )
          );

          await loadLifetimeKPIs();
        } catch (e) {
          console.error(e);
          alert(e.message);
        }
      }

      async function loadWatts() {
        const monthlyQuery = {
          timeDimensions: [{ dimension: 'c2_cube.workout_date', granularity: 'month' }],
          measures: ['c2_cube.avg_watts', 'c2_cube.avg_drag_factor', 'c2_cube.total_distance_km'],
          dimensions: ['c2_cube.machine'],
          filters: [
            { member: 'c2_cube.machine', operator: 'equals', values: ['RowErg', 'SkiErg'] },
          ],
          order: { 'c2_cube.workout_date': 'asc' }
        };
        if (getStartDateEnabled()) {
          const sd = getStartDate();
          if (sd) {
            monthlyQuery.filters.push({ member: 'c2_cube.workout_date', operator: 'afterOrOnDate', values: [sd] });
          }
        }
        try {
          const res = await cubeLoad(monthlyQuery);
          const rows = res.data || res.loadResponse?.data || [];
          const timeKey = rows[0] ? detectTimeKey(rows[0]) : 'c2_cube.workout_date';
          const machineKey = rows[0] ? detectMachineKey(rows[0]) : 'c2_cube.machine';
          const valKey = 'c2_cube.avg_watts';
          const dragKey = 'c2_cube.avg_drag_factor';
          const distKey = 'c2_cube.total_distance_km';
          const labelsSet = new Set();
          const rowSeries = {};
          const skiSeries = {};
          const rowDragSeries = {};
          const skiDragSeries = {};
          const rowDistSeries = {};
          const skiDistSeries = {};
          rows.forEach(r => {
            const label = formatMonthLabel(r[timeKey]);
            labelsSet.add(label);
            const machine = (r[machineKey] || '').trim();
            const v = typeof r[valKey] === 'string' ? parseFloat(r[valKey]) : r[valKey];
            const d = typeof r[dragKey] === 'string' ? parseFloat(r[dragKey]) : r[dragKey];
            const dist = typeof r[distKey] === 'string' ? parseFloat(r[distKey]) : r[distKey];
            if (machine === 'RowErg') {
              rowSeries[label] = isFinite(v) ? v : null;
              rowDragSeries[label] = isFinite(d) ? d : null;
              rowDistSeries[label] = isFinite(dist) ? dist : null;
            } else if (machine === 'SkiErg') {
              skiSeries[label] = isFinite(v) ? v : null;
              skiDragSeries[label] = isFinite(d) ? d : null;
              skiDistSeries[label] = isFinite(dist) ? dist : null;
            }
          });
          const labels = Array.from(labelsSet).sort();
          const rowVals = labels.map(l => rowSeries[l] ?? null);
          const skiVals = labels.map(l => skiSeries[l] ?? null);
          const rowDragVals = labels.map(l => rowDragSeries[l] ?? null);
          const skiDragVals = labels.map(l => skiDragSeries[l] ?? null);
          const rowDistVals = labels.map(l => rowDistSeries[l] ?? null);
          const skiDistVals = labels.map(l => skiDistSeries[l] ?? null);
          const rowMom = computeMoMPercent(rowVals);
          const skiMom = computeMoMPercent(skiVals);

          // Destroy existing charts
          window.__charts?.forEach(c => c.destroy());
          window.__charts = [];

          window.__charts.push(
            makeComboBarLineChart(
              document.getElementById('wattsMonthlyRow'),
              labels,
              rowVals,
              rowMom,
              rowDragVals,
              rowDistVals,
              { bar: '#60a5fa', line: '#93c5fd' },
              'Avg Watts',
              'MoM Change'
            ),
            makeComboBarLineChart(
              document.getElementById('wattsMonthlySki'),
              labels,
              skiVals,
              skiMom,
              skiDragVals,
              skiDistVals,
              { bar: '#22d3ee', line: '#7dd3fc' },
              'Avg Watts',
              'MoM Change'
            ),
          );
        } catch (e) {
          console.error(e);
          alert(e.message);
        }
      }

      async function loadLifetimeKPIs() {
        const lifetimeQuery = {
          measures: ['c2_cube.total_distance_with_rest_km', 'c2_cube.avg_pace'],
          dimensions: ['c2_cube.machine'],
          filters: [
            { member: 'c2_cube.machine', operator: 'equals', values: ['RowErg', 'SkiErg'] },
          ]
        };
        try {
          const res = await cubeLoad(lifetimeQuery);
          const rows = res.data || res.loadResponse?.data || [];
          const machineKey = rows[0] ? detectMachineKey(rows[0]) : 'c2_cube.machine';
          const distKey = 'c2_cube.total_distance_with_rest_km';
          const paceKey = 'c2_cube.avg_pace';

          const toNum = (v) => {
            const n = typeof v === 'string' ? parseFloat(v) : v;
            return isFinite(n) ? n : 0;
          };

          let rowKm = 0, skiKm = 0, rowPace = null, skiPace = null;
          rows.forEach(r => {
            const m = (r[machineKey] || '').trim();
            if (m === 'RowErg') {
              rowKm += toNum(r[distKey]);
              rowPace = r[paceKey] ?? rowPace;
            } else if (m === 'SkiErg') {
              skiKm += toNum(r[distKey]);
              skiPace = r[paceKey] ?? skiPace;
            }
          });
          const totalKm = rowKm + skiKm;

          const formatKm = (n) => new Intl.NumberFormat('en-US', { minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(n);
          const formatPace = (p) => formatSecondsToMMSS(parseTimeToSeconds(p));

          document.getElementById('kpi-total-km').textContent = `${formatKm(totalKm)} km`;
          document.getElementById('kpi-row-km').textContent = `${formatKm(rowKm)} km`;
          document.getElementById('kpi-ski-km').textContent = `${formatKm(skiKm)} km`;
          document.getElementById('kpi-row-pace').textContent = rowPace ? formatPace(rowPace) : '—';
          document.getElementById('kpi-ski-pace').textContent = skiPace ? formatPace(skiPace) : '—';
        } catch (e) {
          console.error(e);
        }
      }

      document.getElementById('reload').addEventListener('click', () => {
        if (activeView === 'summary') return loadSummary();
        if (activeView === 'watts') return loadWatts();
        return loadAll();
      });
      // Tab click handlers
      document.querySelectorAll('.tab').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          // Update ARIA
          document.querySelectorAll('.tab').forEach(b => b.setAttribute('aria-selected', b.classList.contains('active') ? 'true' : 'false'));

          const view = btn.dataset.view || 'daily';
          activeView = view;
          if (view === 'summary') {
            document.getElementById('daily-section').classList.add('hidden');
            document.getElementById('summary-section').classList.remove('hidden');
            loadSummary();
          } else if (view === 'watts') {
            document.getElementById('daily-section').classList.add('hidden');
            document.getElementById('summary-section').classList.add('hidden');
            document.getElementById('watts-section').classList.remove('hidden');
            loadWatts();
          } else {
            activeMachine = btn.dataset.machine || DEFAULT_MACHINE;
            document.getElementById('summary-section').classList.add('hidden');
            document.getElementById('watts-section').classList.add('hidden');
            document.getElementById('daily-section').classList.remove('hidden');
            loadAll();
          }
        });
      });
      function reloadActiveView() {
        if (activeView === 'summary') loadSummary();
        else if (activeView === 'watts') loadWatts();
        else loadAll();
      }
      document.getElementById('start-date').addEventListener('change', reloadActiveView);
      document.getElementById('use-start-date').addEventListener('change', reloadActiveView);
      document.querySelectorAll('input[name="distance-filter"]').forEach(inp => {
        inp.addEventListener('change', reloadActiveView);
      });
      // Initial load after a short delay to let Cube start
      setTimeout(() => { loadAll(); }, 300);
    </script>
  </body>
</html>
